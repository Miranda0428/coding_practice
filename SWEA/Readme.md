**다시 풀어야할 문제**

최대 상금, 공통 조상, 최적 경로 문제는 메모이제이션으로 다시


**문자열 숫자를 정수형 숫자로**

![image](https://user-images.githubusercontent.com/17174701/141229136-f972a47c-bee9-4ead-831f-1d42404d73fc.png)


**2차원 배열을 함수 매개별수로 전달하기**

2차원 배열 arr[100][100]을 함수 인자로 전달하기 위해서는 char arr[][100] 또는 char (*arr)[100] 으로 전달해야 한다.


**재귀호출을 이용한 완전탐색(최대 상금)**

순열 조합 문제는 이것으로 해결 가능, 결국은 dfs!!

연산자 5개로 만들수 있는 가장 큰 수 찾기 

카드 swap해서 최대수 찾기 등에 활용이 많이됨

첫번째 것을 선택하고 안하고/ 두번째 것을 선택하고 안하고....기억

int solve(num, cnt){

  int ret = 0;
  
  if(cnt == 0) return ret;
  
  for(int i=0; i<end; ++i)
  
    solve(f(num), cnt-1);
  
  return ret;
  
  } 와 같은 형식
  
 ![image](https://user-images.githubusercontent.com/17174701/142149908-6eead60e-905f-4542-a8c1-773e0445a5cf.png)

  
  **가중치가 있는 완전탐색(최적 경로)**


정말 고민을 많이 한 문제가 최적 경로 문제이다.

재귀호출로 완전탐색을 구현하는 것은 결국 dfs를 하는 것이고,

최적 경로를 찾는 것은 가중치의 합 중에 최소인 값을 찾는 것이다.

![image](https://user-images.githubusercontent.com/17174701/141939330-27644c7c-a9c2-484e-9891-2486124f7f00.png)


for 문위에 int ret = INF;를 쓰지 않아 하루종일 고민했다.

company가 root이고 home이 말단 노드라고 보면된다.

첫번째 탐색에서 첫번째 갈림길은 company→1→2→3→4→5→home 와 company→1→2→3→5→4→home 이다. 첫번째 경로와 두번째 경로 모두 home까지 갔다가 결과값을 올려준다.

그 결과값은 3에서 만나고 ret에는 첫번째 경로의 결과 그리고 tmp에는 두번째 경로의 결과가 들어있다.

즉, 갈림길에서 갈려서 올라온 결과값들이 비교된 것이고, 갈림길(3)을 만나기 전까진 ret = INF 이다.

타고 올라가다 보면 마지막 갈림길은 company가 되고 그 때 num_customer개의 결과 값 중 가장 작은 값이 최종 ret 값이다.

**고속화를 위해서는 메모이제이션을 한다.**

**가중치가 없는 그래프에서는 bfs로 최단 경로를 구할 수 있다.**
  

**메모이제이션(최적 경로)**
  
  1. #include<memory>를 해주고 memo[N][N]을 전역변수로 선언
  
  2. main에서 memset(arr, 0x00, sizeof(arr))로 초기화
  
  3. 재귀함수에서 레퍼런스 변수로 memo를 지정하고 연산해야 하는 결과가 memo에 있으면 그 값을 리턴한다.
  (ret = INF 선언이 지역변수에서 전역으로 바뀌었다. 잊지말자.)
  
  * 코드가 공식처럼 정해져있으니 외우도록 하자.
  
  ![image](https://user-images.githubusercontent.com/17174701/142144210-d8ece9c2-8e0e-435a-97c2-adee47edfd29.png)

  
**LCA(공통 조상)**
  
  메모이제이션 하기도 어렵도 풀이도 잘 이해되지 않는다.
  
  메모이제이션은 2^k 번째 조상을 배열해 저장해 두는 것이고, 최소 공통 조상을 찾기 위해 사용한다.
  
  2^k 번째 조상을 저장하는 이유는 탐색시에 바로 윗조상이 아닌 1, 2, 4, 8...번째 조상 등 탐색의 폭을 크게 해서
  
  이진 탐색 처럼 탐색 속도를 빠르게 하기 위함이다.
  
  코드로 다시 풀어봐야 한다.

  
  **다익스트라(보급로)**
  
디버깅하고 있을 시간이 없다. 코드 짜는 유형이 있다. 이걸 외워서 시간을 단축해야 한다.
  
**가령 재귀호출시 visited[x][y] = 1 해놓고 solve() 호출 후 다시 visited[x][y] = 0 으로 원복**한다던지
  
가지치기, 메모이제이션 등 많이 나오는 경우의 유형을 외워야 한다.
  
완전탐색, 그리디, dfs-bfs 문제는 50개씩 풀라는 말이 이런 뜻 인가보다.

**상하좌우 순서**를 어떻게 하느냐도 시간초과 또는 오버플로우를 일으킨다.
  
아래와 같이 상후하좌 순서를 정해주어야 빨리 연산된다.(문제에 따라 다를수도)
  
**문자 입력**
  
문자를 입력 받을 때, 띄워서 입력값이 주어지는경우는 scanf("%1d",&data) 붙어서 입력값이 주어지는 경우는 scanf("%1d", &map[i][j]);
  
(%1d는 1개 숫자씩 받는다는 의미)
  
**큰 사이즈의 배열(하나로)**
  
큰 사이즈의 배열 선언시 edge_type을 solve()함수안에 선언하면 스택이 모자라 컴파일이 안됨

  
**K번째 문자열 찾기**
 
set에서 K번째 문자열을 찾으려면 iterator를 만들어야 한다.
  
![image](https://user-images.githubusercontent.com/17174701/143520992-980c9389-c780-4027-a1af-2f01d1e96379.png)
  
  
**트라이(K번째 문자열 찾기)**  
트라이에 대해 잘못 생각하고 있었다. root가 있고 그 밑으로 분기없이 한줄로 죽 이어지는 것이 아니고
부분 문자열중 다른 문자가 나오면 분기가 일어나는 트리의 모양이다.
  
구글에서 '문자열 트라이'를 검색해보면 문자열에서 문자가 달라지는 부분부터 분기가 일어남을 알 수 있다.

나는 트라이를 문어같이 문어대가리가 root 이고 문어다리들이 분기없이 부분 문자열을 나타낸다고 생각했다.
그래서 insert 부분과 solve 부분을 잘못구현했었다.

**플로이드워셜(사람 네트워크2)**

시간복잡도 : O(n^3)

3중 for문을 돌면서 D[i][j] = min(D[i][j], D[i][k]+D[k][j]); 로 distance matrix 를 업데이트 해준다.

i-j 간의 최소거리는 중간 경우하는 k가 있을 경우 i-k, k-j 또한 최소거리라는 것을 기반으로 한다.
  

**LCS(이미지 유사도 검사)**

  최장공통부분 수열 찾기
  
  DP 문제인데 
