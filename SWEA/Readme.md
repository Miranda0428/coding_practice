**다시 풀어야할 문제**

최대 상금, 공통 조상, 최적 경로 문제는 메모이제이션으로 다시


**문자열 숫자를 정수형 숫자로**

![image](https://user-images.githubusercontent.com/17174701/141229136-f972a47c-bee9-4ead-831f-1d42404d73fc.png)


**2차원 배열을 함수 매개별수로 전달하기**

2차원 배열 arr[100][100]을 함수 인자로 전달하기 위해서는 char arr[][100] 또는 char (*arr)[100] 으로 전달해야 한다.


**재귀호출을 이용한 완전탐색(최대 상금)**

순열 조합 문제는 이것으로 해결 가능, 결국은 dfs!!

연산자 5개로 만들수 있는 가장 큰 수 찾기 

카드 swap해서 최대수 찾기 등에 활용이 많이됨

첫번째 것을 선택하고 안하고/ 두번째 것을 선택하고 안하고....기억

int solve(num, cnt){

  int ret = 0;
  
  if(cnt == 0) return ret;
  
  for(int i=0; i<end; ++i)
  
    solve(f(num), cnt-1);
  
  return ret;
  
  } 와 같은 형식
  
 ![image](https://user-images.githubusercontent.com/17174701/142149908-6eead60e-905f-4542-a8c1-773e0445a5cf.png)

  
  **가중치가 있는 완전탐색(최적 경로)**


정말 고민을 많이 한 문제가 최적 경로 문제이다.

재귀호출로 완전탐색을 구현하는 것은 결국 dfs를 하는 것이고,

최적 경로를 찾는 것은 가중치의 합 중에 최소인 값을 찾는 것이다.

![image](https://user-images.githubusercontent.com/17174701/141939330-27644c7c-a9c2-484e-9891-2486124f7f00.png)


for 문위에 int ret = INF;를 쓰지 않아 하루종일 고민했다.

company가 root이고 home이 말단 노드라고 보면된다.

첫번째 탐색에서 첫번째 갈림길은 company→1→2→3→4→5→home 와 company→1→2→3→5→4→home 이다. 첫번째 경로와 두번째 경로 모두 home까지 갔다가 결과값을 올려준다.

그 결과값은 3에서 만나고 ret에는 첫번째 경로의 결과 그리고 tmp에는 두번째 경로의 결과가 들어있다.

즉, 갈림길에서 갈려서 올라온 결과값들이 비교된 것이고, 갈림길(3)을 만나기 전까진 ret = INF 이다.

타고 올라가다 보면 마지막 갈림길은 company가 되고 그 때 num_customer개의 결과 값 중 가장 작은 값이 최종 ret 값이다.

**고속화를 위해서는 메모이제이션을 한다.**

**가중치가 없는 그래프에서는 bfs로 최단 경로를 구할 수 있다.**
  

**메모이제이션(최적 경로)**
  
  1. #include<memory>를 해주고 memo[N][N]을 전역변수로 선언
  
  2. main에서 memset(arr, 0x00, sizeof(arr))로 초기화
  
  3. 재귀함수에서 레퍼런스 변수로 memo를 지정하고 연산해야 하는 결과가 memo에 있으면 그 값을 리턴한다.
  (ret = INF 선언이 지역변수에서 전역으로 바뀌었다. 잊지말자.)
  
  * 코드가 공식처럼 정해져있으니 외우도록 하자.
  
  ![image](https://user-images.githubusercontent.com/17174701/142144210-d8ece9c2-8e0e-435a-97c2-adee47edfd29.png)

  
**LCA(공통 조상)**
  
  메모이제이션 하기도 어렵도 풀이도 잘 이해되지 않는다.
  
  메모이제이션은 2^k 번째 조상을 배열해 저장해 두는 것이고, 최소 공통 조상을 찾기 위해 사용한다.
  
  2^k 번째 조상을 저장하는 이유는 탐색시에 바로 윗조상이 아닌 1, 2, 4, 8...번째 조상 등 탐색의 폭을 크게 해서
  
  이진 탐색 처럼 탐색 속도를 빠르게 하기 위함이다.
  
  코드로 다시 풀어봐야 한다.

  
  **다익스트라(보급로)**
  
디버깅하고 있을 시간이 없다. 코드 짜는 유형이 있다. 이걸 외워서 시간을 단축해야 한다.
  
**가령 재귀호출시 visited[x][y] = 1 해놓고 solve() 호출 후 다시 visited[x][y] = 0 으로 원복**한다던지
  
가지치기, 메모이제이션 등 많이 나오는 경우의 유형을 외워야 한다.
  
완전탐색, 그리디, dfs-bfs 문제는 50개씩 풀라는 말이 이런 뜻 인가보다.

**상하좌우 순서**를 어떻게 하느냐도 시간초과 또는 오버플로우를 일으킨다.
  
아래와 같이 상후하좌 순서를 정해주어야 빨리 연산된다.(문제에 따라 다를수도)
  
**문자 입력**
  
문자를 입력 받을 때, 띄워서 입력값이 주어지는경우는 scanf("%1d",&data) 붙어서 입력값이 주어지는 경우는 scanf("%1d", &map[i][j]);
  
(%1d는 1개 숫자씩 받는다는 의미)
  
**큰 사이즈의 배열(하나로)**
  
큰 사이즈의 배열 선언시 edge_type을 solve()함수안에 선언하면 스택이 모자라 컴파일이 안됨

  
**K번째 문자열 찾기**
 
set에서 K번째 문자열을 찾으려면 iterator를 만들어야 한다.
  
![image](https://user-images.githubusercontent.com/17174701/143520992-980c9389-c780-4027-a1af-2f01d1e96379.png)
  
  
**트라이(K번째 문자열 찾기)**  
트라이에 대해 잘못 생각하고 있었다. root가 있고 그 밑으로 분기없이 한줄로 죽 이어지는 것이 아니고
부분 문자열중 다른 문자가 나오면 분기가 일어나는 트리의 모양이다.
  
구글에서 '문자열 트라이'를 검색해보면 문자열에서 문자가 달라지는 부분부터 분기가 일어남을 알 수 있다.

나는 트라이를 문어같이 문어대가리가 root 이고 문어다리들이 분기없이 부분 문자열을 나타낸다고 생각했다.
그래서 insert 부분과 solve 부분을 잘못구현했었다.

**플로이드워셜(사람 네트워크2)**

시간복잡도 : O(n^3)

3중 for문을 돌면서 D[i][j] = min(D[i][j], D[i][k]+D[k][j]); 로 distance matrix 를 업데이트 해준다.

i-j 간의 최소거리는 중간 경우하는 k가 있을 경우 i-k, k-j 또한 최소거리라는 것을 기반으로 한다.
  

**LCS(이미지 유사도 검사)**

  최장공통부분 수열 찾기, DP 문제
  
  if(str_A[i-1] == str_B[j-1]) LCS[i][j] = LCS[i-1][j-1] + 1;
  
  else LCS[i][j] = max(LCS[i-1][j], LCS[i][j-1]);

  가 핵심이다. LCS[i][j]는 str_A의 i번째 문자와 str_B의 j번째 문자까지 비교했을때 최장공통수열의 길이
  
  str_A의 i번째 문자와 str_B의 j번째 문자가 일치하면 최장공통수열로 선택되므로 LCS[i-1][j-1] + 1;
  
  일치하지 않으면 max(str_A의 i번째 문자가 최장공통수열로 선택됐을때, str_B의 j번째 문자가 최장공통수열로 선택됐을때)
  
  
**소수 완제품일 확률**
  
완제품의 갯수가 18보다 작은 소수 {2,3,5,7,11,13,17} 중 하나일 확률 
  
2개일 경우(18C2 * (p)^2 * (1-p)^(18-2)) + 3개일 확률 + ... + 17개일 확률
  
최소 둘 중 한명이 만든 완제품의 갯수가 소수일 확률 = 1 - (1-A가 만든 완제품의 갯수가 소수일 확률)(1-B가 만든 완제품의 갯수가 소수일 확률)
  
즉, A가 만든 완제품의 갯수가 소수일 확률+B가 만든 완제품의 갯수가 소수일 확률-(A가 만든 완제품의 갯수가 소수일 확률)(B가 만든 완제품의 갯수가 소수일 확률)
  
  **INF(All Pair Shortest Path)**
  
  INF 값을 정할때도 주의해야 할 것이 가중치를 더할때 INF에 더해서 음수값으로 변하는 경우가 생긴다.
  
그래서 나는 이런 오류를 피하기 위해 D 매트릭스 초기화시 -1을 사용하였다.
  
  
  **memset(All Pair Shortest Path)**
  
  바이트별로 hex값으로 초기화하기 때문에 0 또는 -1이 아니면 생각지 못한 값으로 덮어쓸 수 있으니 유의해야한다.
  
  
  **Big Integer ADD & MUL(타일링)**
  
  big integer를 위한 STL은 없다.
  
  big integer를 자료형은 각 자리 숫자를 문자로 하는 string이며 각 자리수 연산을 십진수로 한다.
  
  각 자리 십진수 연산할 때만 integer로 바꾸고 연산 후에는 다시 string으로 바꿔준다. 결과값이 10을 넘으면 carry를 1로 세팅하고 다음 자리수 연산때 더해준다.
  
  내가 짠 것이 아니기 때문에 다음에 내가 다시 짜보도록 하자.
  
  ![image](https://user-images.githubusercontent.com/17174701/145165274-c0fe62f7-cc21-4c18-84a4-a484bc57daff.png)

  
  
  참고로 여기서도 memset 실수를 했다. 주의하자!
  
  
  **MST(고속도로 건설2)**
    
주 반복문이 정점의 수 n만큼 반복하고, 내부 반복문이 n번 반복

Prim의 알고리즘의 시간 복잡도는 O(n^2) 이 된다.

Kruskal 알고리즘의 시간 복잡도는 O(elog₂e) 이므로

그래프 내에 적은 숫자의 간선만을 가지는 ‘희소 그래프(Sparse Graph)’의 경우 Kruskal 알고리즘이 적합하고

그래프에 간선이 많이 존재하는 ‘밀집 그래프(Dense Graph)’ 의 경우는 Prim 알고리즘이 적합하다.
  
그래프에 간선이 많이 존재하는 ‘밀집 그래프(Dense Graph)’ 의 경우는 Prim 알고리즘이 적합하다.
  
이 문제에서는 Prim 으로 푸니 시간 초과가 발생했다.
  
Kruscal을 쓰더라도 findset을 최적화시키지 못하면 시간 초과가 발생했다.
  
그 원인을 찾아보아야 한다.
